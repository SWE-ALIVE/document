\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{caption}


\setlength{\parindent}{1em}  % 문단 들여쓰기 설정

\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
    
\begin{document}
    
\title{ALIVE\\{\large
 An AI-Driven Multi-Agent Chat System for Intuitive Smart Home Management
 }
}

% Team Member 소개
\author{\IEEEauthorblockN{Jun Seong Pyo}
\IEEEauthorblockA{\textit{College of Engineering} \\
\textit{Hanyang University}\\
\textit{Dept.of Information Systems}\\
Seoul, Korea \\
standardstar@hanyang.ac.kr}

\and

\IEEEauthorblockN{Byeong Hyun Yang}
\IEEEauthorblockA{\textit{College of Engineering} \\
\textit{Hanyang University}\\
\textit{Dept.of Information Systems}\\
Seoul, Korea \\
zxvm5962@hanyang.ac.kr}

\and

\IEEEauthorblockN{Dong Hun Kang}
\IEEEauthorblockA{\textit{College of Engineering} \\
\textit{Hanyang University}\\
\textit{Dept.of Information Systems}\\
Seoul, Korea \\
kdu3840@hanyang.ac.kr}

\and

\IEEEauthorblockN{Hye Jin Bae}
\IEEEauthorblockA{\textit{College of Engineering} \\
\textit{Hanyang University}\\
\textit{Dept.of Information Systems}\\
Seoul, Korea \\
cats5565@hanyang.ac.kr}
}

\maketitle


\begin{abstract}
Smart home provides automated control and convenience in home environments. Although smart homes have improved convenience in daily life, their rigid and uniform structures limit customization and integration of diverse information sources, leading to passive and inflexible management systems. We propose a new multi-turn AI based Chat Room system, Alive, which enables users to manage and control home appliances. With Alive, users can register home appliances directly or import them from compatible apps, allowing them to create custom chat rooms for seamless device management. Through our appliance chat rooms, users can identify the most suitable appliances for specific situations and execute them simultaneously, simplifying the process of smart home control. Users can efficiently manage and control their appliances at any time through the chat interface. Furthermore, we've integrated a human feedback mechanism to improve the system. Users can evaluate their experience after the end of process, providing valuable insights for continuous enhancement of the application. This data is systematically stored and utilized for learning and refining the system's performance. Alive represents a significant step forward in smart home technology, addressing the need for more flexible, user-centric solutions in the evolving landscape of home automation.
\end{abstract}

% Role Assignment
\begin{table}[h] \\
\caption{Role Assignments}
\def\arraystretch{1.24} \small

\begin{tabular}{|p{1.5cm}|p{1.2cm}|p{4.9cm}|}
    \hline
    Roles & Name & Task description and etc. \\ 
    \hline
    User, \par Customer,\par Development \par manager & Pyo \par Jun Seong & Users/customers consider what features should be added from the perspective of users or customers. They think about what needs exist and what solutions could address these needs.
    The Development Manager takes charge of the project's comprehensive elements, including timeline creation, strategic planning, and maintaining the quality standards of products and services. Furthermore, they ensure a thorough understanding of user specifications and oversee the complete software engineering lifecycle, encompassing phases such as design, implementation, and quality assurance testing.\\
    \hline
\end{tabular}
\end{table}

\begin{table}
\def\arraystretch{1.24} \small 

\begin{tabular}{|p{1.5cm}|p{1.2cm}|p{4.9cm}|}
    \hline
    AI \par Developer & Yang \par Byeong Hyun & AI developers create customized programs tailored to business needs based on collected and analyzed data. In this service, they build AI systems that present various scenarios using users' historical data and user requirements. Specifically, they apply multi-agent technology to provide accurate and personalized responses to user requirements. AI developers are responsible for the design, development, implementation, and monitoring of the entire AI system, focusing on building efficient data collection and transformation architectures.  \\ 
    \hline
    Software \par Developer \par(Back-end) & Kang \par Dong hun & Software developers (backend) design and manage server-side infrastructure and database systems required for project development. This includes building and maintaining robust backend solutions that support the capabilities of web and mobile applications, and ensuring seamless integration with front-end components. This includes database operations, efficient query generation, and API endpoint implementation. It also involves leveraging Java, Kotlin, and Spring programming languages to develop scalable and maintainable systems that meet the requirements of the project. \\ 
    \hline
    Software \par Developer\par(Front-end) & Bae \par Hye jin & Software Developers (Front-end) are responsible for designing and implementing the overall UI/UX of applications to create exceptional user experiences. They craft visual layouts and interactive elements, ensuring interfaces are aesthetically pleasing, intuitive, and user-friendly. Using tools like Figma, they create and refine designs, which they then implement using technologies such as React-Native, TypeScript, and CSS. The role involves creating responsive interfaces, optimizing performance, and ensuring accessibility throughout the development process.\\ 
    \hline
\end{tabular}
\end{table}

% Introduction 시작
\section{INTRODUCTION}

\subsection{Motivation}

\begin{itemize}
    \item [1)] The Advancement of AI Technology and the Rise of Multi-Agent Systems \\ \\
     Artificial intelligence technology has been developing at an astonishing rate over the past few years. In 2016, Google DeepMind's AlphaGo defeating the world's top Go player marked the beginning of the AI era. Since then, AI technology has become even more sophisticated, with the release of OpenAI's ChatGPT in late 2022 ushering in the era of generative AI. ChatGPT reached 1 million users within a week of its launch and saw explosive growth, surpassing 100 million active users in just two months.

    \hspace{1em} In 2023, GPT-4 was released, showcasing even more advanced features. GPT-4 evolved into a multimodal model that can simultaneously process various input data such as text, images, audio, and video, utilizing a dataset about 500 times larger than its previous model. These advancements reflect a broader trend in AI development, where the technology is moving beyond simple content generation to more complex, interactive, and adaptive capabilities.
    
    \hspace{1em} The future of the AI industry points to evolve from generative models to autonomous agents, ushering in an era of multi-agents where multiple agents collaborate, think, and learn independently. This evolution will likely lead to the integration of multi-agent systems within the Artificial Intelligence of Things (AIoT), which combines AI and the Internet of Things (IoT), and is expected to spread to various industries, centered around manufacturing. \\

    \item [2)] IoT Technology Market Trends and the Current Status of Smart Homes  \\ \\
    The spread of IoT technology is dramatically changing all aspects of daily life, with `smart homes' being a prime example. In smart homes, home appliances and various devices are interconnected via the internet, allowing users to control them remotely and automate daily tasks.  The smart appliance market continues to grow rapidly, fueled by increasing consumer interest in convenience, energy efficiency, and personalized living environments. 

    \hspace{1em} Despite widespread awareness and adoption of smart home devices, many users are not fully utilizing their potential. Over Half of users (53.1\%) still rely on basic functions like power control and status monitoring, while advanced capabilities such as automation or device interlinking remain underutilized. This indicates a gap between the technology's capabilities and how users engage with it, suggesting a need for more intuitive interfaces and seamless integration to encourage deeper interaction.
    
    \hspace{1em} As smart home technology continues to evolve, there is a growing opportunity to move beyond simple control features and offer more intelligent, adaptive experiences that anticipate users' needs. The next step for smart homes involves leveraging AI to enable dynamic collaboration among devices, creating environments that actively respond to user behavior and preferences.
    
    \hspace{1em} Our team's goal is to push the boundaries of smart home technology by advancing from passive AI systems to dynamic and intelligent interactions. We aim to deliver optimal results for users by implementing the ability for smart devices to communicate with each other using Large Language Models (LLMs). Through this solution, we aim to address the current gap between the potential of smart home technology and its real-world use to increase access and smoothness to advanced automation, ultimately improving the daily life experience of individual users.
\end{itemize}


\subsection{Problem Statement}
\begin{itemize}
    \item [a.] Need for improved Customization and Differentiated User Experience \\ \\
    According to the Smart Home Trend Report 2023, major dissatisfaction factors for smart home appliances include `lack of additional functions when using devices in conjunction'. The response `lack of additional functions when using devices in conjunction' suggests that users are not fully utilizing the functions of smart home appliances. In fact, while smart appliances offer various functions through applications, customer satisfaction is declining as users fail to effectively utilize these functions. This indicates the need for improved Customization and User Experience so that users can effectively use them. \\ 
    
    \item [b.] Limited and Uniform Scenarios \\ \\ 
    While the current routine functions of smart appliances are useful for automating users' daily patterns, they have limitations in responding to complex and diverse real-life scenarios. For example, in situations with many variables such as sudden weather changes, pre-set routines alone are insufficient for appropriate responses. Moreover, it's difficult to flexibly handle complex interactions between various appliances or immediate changes in user demands. Therefore, for a truly smart home solution, more advanced technologies such as real-time situation awareness and machine learning are needed. This requires the development of intelligent systems that can understand users' living patterns more deeply and respond according to the situation. \\
    
    \item [c.] Limitations of Passive and Individual Management \\ \\
    Despite being labeled as `smart', current smart home appliances still heavily rely on passive and individual management by users. In most cases, users need to adjust settings for each device separately and make judgments and decisions for various situations directly. For example, user intervention is required in many aspects such as adjusting the air conditioner's temperature, selecting the washing machine's cycle, or setting the robot vacuum's cleaning schedule. Furthermore, even in routine settings, users have to perform logical structure design themselves, which can lead to logical errors. This indicates that the focus is on the independent operation of each device rather than on device interconnection and overall home environment optimization.\\
    
    \item [d.] Lack of Information Integration \\ \\
    Smart home applications individually offer rich features and information. Each app provides useful data such as energy usage monitoring, device status checks, and even general lifestyle information. However, these diverse information and functions are not connected into a single integrated system, which limits the user experience. As a result, users must open each section separately to check information and make their own judgments to decide on their next actions based on this information. This hinders the convenience and efficiency of smart homes, causing users the inconvenience of having to manually integrate and analyze multiple pieces of information.
    
\end{itemize} 


\subsection{Solution}
\begin{itemize}
    \item [a.] Providing Customized Services and improving user Experience \\ \\ 
    It is necessary to improve the user experience by providing customized services that meet user needs. This can be achieved by using AI to provide user-customized interfaces and improve user experience through more user interactions.

    \hspace{1em} Specifically, in this system, when the user simply instructs a task via chat or voice, AI coordinates the `conversation' between home appliances to derive the optimal execution plan. It obtains user confirmation before execution, suggests alternatives based on changing situations, and learns user preferences. It also collects feedback after task completion for continuous improvement.
    
    \hspace{1em} This approach goes beyond simply controlling devices, providing a true smart home experience that deeply understands and reflects the user's intentions and values. As a result, users can enjoy a home environment perfectly tailored to their lifestyle and preferences without complex settings, making the interaction between technology and humans more natural and efficient.\\
    
    \item [b.] AI-based Integrated Control and Scenario Optimization \\ \\
    LLM (Large Language Model) technology can generate and analyze various complex scenarios. Based on tasks instructed by users via chat or voice, LLM can establish comprehensive preparation plans.
    
    For example, with just the simple information that ``friends are coming over tonight," LLM can establish a comprehensive preparation plan including lighting settings, indoor temperature adjustment, music playback, and activating cleaning robots. In this process, LLM suggests optimal solutions considering the user's past preferences, current situation, and energy efficiency.
    
    \hspace{1em} If changes are needed during execution, LLM immediately generates alternatives and provides options to the user. Additionally, by analyzing feedback collected after task completion, it can provide better solutions in similar situations in the future. In this way, LLM acts as an intelligent mediator between users and appliances, contributing to more accurately understanding and realizing the user's intentions.\\
    
    \item [c.] Integrated Control Between Devices and Adaptation to Changing Environments \\ \\ 
    The optimization of environment-adaptive scenarios through integrated control systems and collaboration between products greatly enhances the efficiency and user experience of smart homes. Each device performs status checks and transmissions, and the central control system monitors this and comprehensively analyzes data collected from each device.
    
    \hspace{1em} Based on this, dynamic adjustments between devices are made according to changing environmental conditions (e.g., weather changes, indoor air quality, user activity patterns). For example, when the temperature rises, the air conditioner and blinds can work together to efficiently maintain indoor temperature, or the air purifier and ventilation system can be linked to create an optimal indoor air environment.
    
    \hspace{1em} This system maintains the optimal living environment continuously with minimal user intervention and can flexibly respond to unpredictable situations, thus implementing a smart home in the true sense of the term. Furthermore, by entrusting logical structure design to AI, it can solve the problem of logical errors that may occur when users set it directly.\\
    
    \item [d.] Integration of IoT Technology and Information \\ \\
    Integrating and utilizing the diverse information and functions provided by IoT devices greatly improves the efficiency of smart home systems. Current smart home appliances, i.e., IoT devices, offer a wide variety of convenient functions, but users are not fully utilizing them.
    
    \hspace{1em} To solve this problem, we propose managing various lifestyle information such as energy consumption, indoor environmental data, user schedules, and weather information provided by apps comprehensively on a single platform. This integrated information is used for smarter decision-making by home appliances.
    
    \hspace{1em} For example, a washing machine can analyze the user's schedule and power usage patterns to suggest optimal operating times. This integrated approach enables complex scenario settings that optimize the entire home environment, going beyond simple automation of individual devices.
    
    \hspace{1em} As a result, users can enjoy a more convenient and energy-efficient smart home experience. Additionally, it allows users to easily obtain information and maximize the interaction effect with IoT devices and, by extension, with the smart home.
\end{itemize}


\subsection{Research on Related Software}

\begin{itemize}
\item [1.]LG ThinQ ON\\
LG ThinQ ON is an AI home hub equipped with Furon, which integrates various large language models (LLM) into the LG ThinQ platform. This system continuously monitors the home environment and appliances, engaging in conversations with users to assess situations and optimally control devices. Unlike traditional voice recognition speakers that provide simple responses and execute predefined commands, LG ThinQ ON offers a more interactive and intelligent experience. \\
\item [2.]SmartThings\\
SmartThings is Samsung’s integrated smart home platform that allows users to easily control and manage various IoT devices through a mobile app. This platform include SmartThings Energy, an AI-based automated energy management service that optimizes energy usage through the ``Energy AI Save Mode," and SmartThings Air Care, which controls air flow recommends appropriate air purification methods.\\
\item [3.]Amazon Alexa Hunches\\
Amazon Alexa Hunches is a feature that enables Alexa to learn user patterns related to smart home devices. It proactively suggest actions or automatically perform tasks based on these behaviors. Additionally, users can configure Alexa to execute actions automatically with their consent. Hunches also helps optimize energy consumption by monitoring the status of devices such as lights, thermostats, and plugs, thereby assisting in energy savings.
\\
\item [4.]Vivint Smart Home\\
Vivint Smart Home is a home automation and security platform that provides comprehensive smart home solutions, including security cameras, smart locks, lighting, and energy management systems. It integrates various smart devices into a single system, enabling users to control their home environment via the Vivint app or voice commands through smart assistants. Vivint's security-focused features, such as professional monitoring and customizable alerts, ensure safety, while its smart home automation enhances convenience and energy efficiency for users.
\\
\item [5.]Apple HomeKit\\
Apple HomeKit is a software framework that allows users to configure, communicate with, and control smart appliances through Apple devices such as iPhones and macOS computers. It supports both Apple’s own products and those compatible with Matter, enabling users to register devices using their setup codes. HomeKit facilitates the management of these devices, allowing for control and the registration of detailed routines.
\\
\item [6.]Google Nest Hub\\
Smart display developed by Google, this provides a range of smart home features based on Google Assistant. It extends the voice-centric capabilities of Google Home by adding conversational interactions and learning user behavior patterns to better understand and anticipate their needs. In addition, its display-based interface offers visual feedback, enhancing user interaction with smart home devices and delivering a more intuitive and engaging experience.
\\
\item [7.]Azure IoT Hub\\
Azure IoT Hub is a versatile and scalable cloud platform (IoT PaaS) that caters to multiple tenants. It comprises an IoT device registry, data storage, and robust security features. It also offers a service interface to facilitate IoT application development.
\\
\item [8.]ChatThinQ\\
ChatThinQ is an AI feature within LG's ThinQ platform that enhances smart home interactions. By using large language models, it supports natural, context-aware conversations for controlling appliances, offering personalized recommendations, and providing status updates. It can proactively suggest actions, optimize device settings, and create custom routines based on user preferences. The multi-turn dialogue capability ensures fluid interactions, making the smart home experience more intuitive and engaging.

\end{itemize}


\section{REQUIREMENT}

\begin{itemize}
    \item [A.] Sign up \\
    ALIVE needs five types of information to sign up. These are phone numbers, passwords, name, email, and birth dates.
\end{itemize}
\begin{enumerate}
    \item Enter phone numbers \\
    The phone number must be entered, and the phone number is verified through the carrier’s authentication system to confirm whether the phone number is valid for membership registration. The phone number serves as an ID in the subsequent login process.

    \item Enter passwords \\
    Passwords must be entered and must be at least 8 characters long in a combination of 3 or more of English uppercase, English lowercase, numbers, or special characters. When the user enters the desired password, it is displayed in the form of ‘****’ on the screen, with each condition changing color to green when it is satisfied, and red when it is not.

    \item Enter a name \\
    The name must be entered, and it is subsequently set as the default nickname at the first login. The name is also used in ID search.

    \item Enter birth dates \\
    The birth date must be entered, and a pop-up window is displayed every year to celebrate the user's birthday. The date of birth is also used in ID search. \\
\end{enumerate}

\begin{itemize}
    \item [B.] Sign in \\
    There are two types of logins: 1) Local logins through ALIVE membership, 2) SNS logins through SNS linkage.
\end{itemize}

\begin{enumerate}
    \item Local logins through ALIVE membership
    \begin{enumerate}
        \item The system checks whether the ID and password entered by the user have been filled.
        \item When the ID and password input by the user exist in the member database, the user succeeds in logging in. After that, it moves to the main page.
        \item If the phone number and password entered by the user do not exist in the member database, the user fails to log in and a “Non-existent member” message is displayed in the pop-up window. \\
    \end{enumerate}
\end{enumerate}

\begin{itemize}
    \item [C.] Register home appliances 
    You can register your appliances in ALIVE in two ways: 1) Register your appliances directly, 2) Import your registered appliances from the LG ThinQ app.
\end{itemize}

\begin{enumerate}
    \item Register your appliances directly
    \begin{enumerate}
        \item via QR code: When the camera access permission request screen appears, simply follow the instructions to grant access. After that, locate the QR code on each product. Scan the QR code along the guide lines on the edge.
        \item find appliances on your own: you can search for appliances by two methods:
        \begin{itemize}
            \item Wi-Fi or Bluetooth
            \item Product name and serial number
        \end{itemize}
    \end{enumerate}
    \item Import from LG ThinQ \\
    You can import a list of appliances pre-registered in the LG ThinQ app. After clicking the `Import from LG ThinQ' button, the LG ThinQ app will open. The user must agree to the following:
    \begin{itemize}
        \item Agree to import the information of the registered home appliances into the app.
        \item Agree to import the settings from the ThinQ app into the app.
    \end{itemize}
    If information is imported from the LG ThinQ app, it may include the following:
    \begin{itemize}
        \item Registered home appliances
        \item Room list and list of appliances added to the room
        \item Smart routines
    \end{itemize}
    After all the settings are imported, the following chat rooms will be opened automatically:
    \begin{itemize}
        \item A chat room with all your appliances
        \item A room-specific chat room \\
    \end{itemize} 
\end{enumerate}

\begin{itemize}
    \item [D.] Creation of Appliance Chat Rooms
\end{itemize}

\begin{enumerate}
    \item Integration with LG ThinQ App \\
    Enable users to retrieve all connected electronic appliances by integrating with the LG ThinQ app. Ensure seamless synchronization so that any changes in connected devices are reflected in the chat application.

    \item Automatic Generation of Default Chat Room \\
    Automatically generate default chat rooms during the initial setup, including all connected appliances and grouping them by room. This provides users with immediate access to control all their devices without additional configuration.

    \item Custom Chat Room Creation \\
    Allow users to create new chat rooms through the ``+" button at the top right corner of the screen, and invite only the appliances they wish to include.

    \item Support for Multiple Chat Rooms \\
    Permit the creation of multiple chat rooms to manage appliances based on rooms, functions, or user preferences.

    \item Dynamic Management of Appliances \\
    Enable users to later invite additional appliances or remove existing ones. Provide easy-to-use interfaces for managing device participation within chat rooms.
\end{enumerate}

By incorporating these features, users can efficiently manage their connected appliances through customizable chat rooms. This approach enhances usability and provides personalized control over their smart home environment, allowing for a more intuitive and flexible user experience. \\

\section{DEVELOPMENT ENVIRONMENT}

\subsection{Choice of software development platform}
\begin{enumerate}
\item[1] Development Platform

\begin{itemize}
\item [1)] Windows\\
Windows provides a wide range of development tools and integrated development environments (IDEs) for creating various types of applications, including web applications, desktop applications, mobile apps, and games. This supports effective code editing, debugging, testing, deployment, and collaboration, ultimately enhancing developers’ productivity. Furthermore, Windows supports multiple programming languages and frameworks, allowing developers to choose their preferred languages and technologies to flexibly meet project requirements. Windows offers a user-friendly and intuitive interface, making it easy for developers to configure and manage their development environments. A robust community and support system enable developers to share experiences and receive assistance. Lastly, Windows continuously updates and improves, ensuring access to the latest technologies and tools, empowering developers to stay current and modernize their applications. Windows is recognized as a versatile platform suitable for various software
development fields, playing a crucial role in turning developers’ ideas into reality. \\

\item [2)] macOS\\
macOS is a highly regarded operating system in the field of software development, known for its user-friendly interface and exceptional versatility. This operating system offers several advantages to developers, and let’s explore some of them. Firstly, macOS provides essential development tools and an integrated development environment (IDE) for creating a wide range of applications, including web applications, desktop applications, mobile apps, and games. Official IDEs like Xcode are powerful tools for application development across various platforms such as macOS, iOS, watchOS, and tvOS. They support tasks like code writing, debugging, testing, deployment, and collaboration, significantly enhancing developer productivity. Additionally, macOS supports a variety of programming languages and frameworks, allowing developers to choose their preferred languages and technologies, making it flexible to adapt to project requirements. macOS offers an intuitive and user-friendly interface that simplifies development environment setup and project management. The active macOS developer community provides a platform for sharing experiences and collaboration among developers. Finally, macOS ensures access to the latest technologies and tools through continuous updates and improvements. Apple’s dedication to innovation provides developers with the necessaryfeatures to leverage the latest technologies and modernize their applications. For these reasons, macOS is recognized as an essential platform for software development, playing a significant role in turning ideas into reality.
\\
\end{itemize}

\item[2] Language / Framework

\begin{itemize}
\item [1)] Programming Languages
\begin{itemize}
\item [(1)] React Native\cite{ReactNative}
\begin{figure}[h]
\centering
\includegraphics[width=.7\columnwidth]{img/DevEnv/ReactNative.png}
\centering
\caption{React Native} 
\end{figure}\\
React Native is a cross-platform framework developed by Facebook, enabling developers to build iOS and Android applications simultaneously using JavaScript. React Native ensures a consistent UI/UX across platforms while providing high compatibility with native modules, allowing optimal user experiences without compromising performance. Leveraging React's component-based architecture, it maximizes code reusability, which enhances project efficiency and manageability. Consequently, React Native supports fast release cycles and delivers high-quality mobile applications, making it a powerful solution for efficient mobile app development.\\

\item [(2)] TypeScript\cite{Typescript}
\begin{figure}[h]
\centering
\includegraphics[width=.5\columnwidth]{img/DevEnv/TypeScript.png}
\centering
\caption{Typescript} 
\end{figure}
TypeScript is a superset of JavaScript developed by Microsoft, introducing a static type system that improves code stability and readability. TypeScript catches errors at compile time, reducing runtime issues and enhancing maintainability, especially for large-scale projects. Its rich type inference allows developers to clearly define code structure and intent, fostering better collaboration and improving code quality. Ultimately, TypeScript enables the writing of robust, high-performance applications while retaining JavaScript’s flexibility.\\

\item [(3)] Kotlin\cite{Kotlin}
\begin{figure}[h]
\centering
\includegraphics[width=.6\columnwidth]{img/DevEnv/Kotlin.png}\centering
\caption{Kotlin} 
\end{figure}\\
Kotlin is a modern language developed by JetBrains and widely adopted as a Java alternative, particularly in Android development. With concise syntax and a strong type system, Kotlin simplifies code writing and maintenance, allowing developers to produce efficient, maintainable code. Its seamless Java interoperability supports integrating new code into legacy projects, improving productivity and minimizing runtime issues. Kotlin empowers Android developers to build efficient applications with better user experiences, making it an ideal choice for modern, high-quality programming.\\

\end{itemize}
\item [2)] Frameworks
\begin{itemize}
\item [(1)] Spring Boot\cite{SpringBoot}
\begin{figure}[h]
\centering
\includegraphics[width=.7\columnwidth]{img/DevEnv/SpringBoot.png}
\caption{Spring Boot} 
\end{figure}\\
Spring Boot is a framework designed to simplify the development of Java-based web applications and microservices. This framework offers streamlined configuration, an embedded web server, automatic setup, starter dependencies, monitoring and management tools, robust microservices support, and integration with a vast ecosystem of libraries and tools. By using Spring Boot, developers can accelerate application development, simplify complex configurations, and boost overall productivity, making it an ideal choice for scalable and maintainable applications.\\

\item [(2)] Hibernate\cite{Hibernate}
\begin{figure}[h]
\centering
\includegraphics[width=.6\columnwidth]{img/DevEnv/Hibernate.jpg}
\caption{Hibernate} 
\end{figure}\\
Hibernate is an open-source Object-Relational Mapping (ORM) framework for Java, facilitating seamless interaction between Java objects and relational databases. Hibernate offers database independence, automatic schema generation, an Object-Oriented Query Language (HQL), caching support, integrated transaction management, and a well-established community and ecosystem. In essence, Hibernate optimizes database operations in Java applications, providing flexibility, efficiency, and cross-database portability.\\

\item [(3)] FastApi\cite{FastAPI}\\
\begin{figure}[h]
\centering
\includegraphics[width=.8\columnwidth]{img/DevEnv/FastApi.png}
\caption{FastApi} 
\end{figure} \\ 
FastAPI is a modern Python-based web framework designed for fast and efficient API development. FastAPI offers asynchronous support and data validation through Pydantic, maximizing developer productivity. Its automatic OpenAPI and JSON Schema documentation simplifies API testing and enhances collaboration. Renowned for its high performance, FastAPI is widely adopted across fields like machine learning model deployment and data analysis, making it a trusted choice for designing reliable APIs.\\

\subsection{Software in use}
\begin{enumerate}
\item[1] visual Studio Code
\begin{figure}[h]
\centering
\includegraphics[width=.4\columnwidth]{img/SoftInUse/VisualStudioCode.png}
\caption{Visual Studio Code} 
\end{figure}\\
Visual Studio Code is a lightweight yet powerful source code editor developed by Microsoft, optimized for modern development workflows. It offers essential features including IntelliSense code completion, debugging support, and Git integration, while maintaining high performance. The editor's extensive marketplace provides diverse extensions supporting various programming languages and frameworks, particularly beneficial for React Native development. Its customizable interface and integrated terminal enhance development efficiency, making it an ideal choice for cross-platform mobile application development.
\\

\item[2] Xcode
\begin{figure}[h]
\centering
\includegraphics[width=.5\columnwidth]{img/SoftInUse/Xcode.png}
\caption{Xcode} 
\end{figure}\\
Xcode is Apple's integrated development environment (IDE) essential for iOS app development and simulation. It provides comprehensive tools including iOS simulators, debugging capabilities, and Interface Builder for UI design. While primarily used for native iOS development, it serves as a crucial tool for React Native developers by offering high-fidelity iOS simulation and testing environments. The IDE integrates seamlessly with Apple's development ecosystem, providing essential features like device management, performance profiling, and automated testing capabilities for ensuring iOS app quality.\\

\item[3] Github
\begin{figure}[h]
\centering
\includegraphics[width=.4\columnwidth]{img/SoftInUse/Github.png}
\caption{Github} 
\end{figure}\\
GitHub is a cloud-based platform for version control and collaborative software development using Git. It provides essential features including repository hosting, branch management, pull requests, and issue tracking. The platform enables smooth team collaboration through code review tools, project management features, and continuous integration/deployment capabilities. With its extensive documentation support and robust security features, GitHub serves as a centralized hub for maintaining code quality and managing development \\

\item[4] Figma
\begin{figure}[h]
\centering
\includegraphics[width=.5\columnwidth]{img/SoftInUse/Figma.png}
\caption{Figma} 
\end{figure}\\
Figma is a collaborative web-based interface design tool for creating user interfaces and prototypes. It offers powerful design features including component-based systems, auto-layout, and interactive prototyping capabilities. The platform allows real-time collaboration among designers and developers, streamlining the design-to-development workflow with efficient handoff tools and design system management. With its cloud-based nature and extensive plugin ecosystem, Figma enhances team productivity and ensures consistent design implementation across projects.\\

\item[5] Jira
\begin{figure}[h]
\centering
\includegraphics[width=.7\columnwidth]{img/SoftInUse/Jira.png}
\caption{Jira} 
\end{figure}\\
Jira is an agile project management tool developed by Atlassian that streamlines software development processes. It provides comprehensive features for issue tracking, sprint planning, and workflow customization. The platform offers robust reporting tools, integration capabilities with development tools, and flexible board views for different agile methodologies. With its detailed task management and progress tracking features, Jira enables teams to effectively monitor project progress and maintain development efficiency.\\


\item[6] IntelliJ
\begin{figure}[h]
\centering
\includegraphics[width=.4\columnwidth]{img/SoftInUse/Intellij.png}
\caption{IntelliJ} 
\end{figure}\\
IntelliJ IDEA is a comprehensive Java-based integrated development environment (IDE) developed by JetBrains. It offers advanced code analysis, intelligent code completion, and powerful refactoring tools that enhance development productivity. The IDE provides robust debugging capabilities, seamless integration with various frameworks, and extensive plugin support for multiple programming languages. With its smart code navigation and efficient build tools, IntelliJ IDEA accelerates development processes while maintaining code quality and consistency.\\

\item[7] Notion
\begin{figure}[h]
\centering
\includegraphics[width=.4\columnwidth]{img/SoftInUse/Notion.png}
\caption{Notion} 
\end{figure}\\
Notion is a versatile collaborative workspace that unifies note-taking, task management, and documentation tools. The platform excels in organizing information through customizable databases, interconnected pages, and flexible templates. Its all-in-one approach combines wiki-style documentation, project tracking, and team coordination capabilities. With its adaptable interface and cross-platform accessibility, Notion simplifies knowledge sharing and enhances team communication across projects.\\

\item[8] PostgreSQL
\begin{figure}[h]
\centering
\includegraphics[width=0.4\columnwidth]{img/SoftInUse/PostgreSQL.png}
\caption{PostgreSQL} 
\end{figure}\\
PostgreSQL is an advanced open-source relational database management system known for its reliability and data integrity. The system supports complex queries, custom functions, and multi-version concurrency control for efficient data handling. Its architecture enables handling of diverse workloads, from single machines to distributed systems, while maintaining robust security features. With extensive support for SQL standards and scalable performance, PostgreSQL stands as a preferred choice for managing structured data in modern applications.\\

\item[9] Overleaf
\begin{figure}[h]
\centering
\includegraphics[width=.7\columnwidth]{img/SoftInUse/Overleaf.png}
\caption{Overleaf} 
\end{figure}\\
Overleaf is a web-based LaTeX editor that facilitates academic writing and document preparation. The platform combines real-time preview capabilities, extensive template libraries, and reference management tools for scholarly publications. Its browser-based environment enables collaborative writing among researchers, supporting version control and simultaneous editing features. With its integrated compilation engine and comprehensive documentation, Overleaf streamlines the creation of professional academic documents and research papers.\\

\item[10] Postman
\begin{figure}[h]
\centering
\includegraphics[width=.4\columnwidth]{img/SoftInUse/Postman.png}
\caption{Postman} 
\end{figure}\\
Postman is a specialized API development and testing platform that simplifies the API lifecycle management. The tool offers intuitive request building, automated testing sequences, and detailed response validation capabilities. Its environment management system facilitates API testing across different configurations while supporting team collaboration through shared workspaces. With comprehensive documentation generation and mock server features, Postman accelerates API development and ensures reliable endpoint functionality.\\
\\
\\
\\
\item[11] ChatGPT
\begin{figure}[h]
\centering
\includegraphics[width=.4\columnwidth]{img/SoftInUse/ChaGPT.png}
\caption{ChatGPT} 
\end{figure}\\
ChatGPT is an AI-powered API that integrates generative AI capabilities into applications through OpenAI's endpoints. The service, based on GPT-3.5 and GPT-4 models trained on extensive datasets, provides natural language processing functionalities. Through REST API integration, it enables features like text generation, language translation, and content summarization in applications. Its flexible token-based system and documented endpoints allow developers to implement sophisticated AI features effectively.\\

\item[12] Azure
\begin{figure}[h]
\centering
\includegraphics[width=.6\columnwidth]{img/SoftInUse/Azure.png}
\caption{Azure} 
\end{figure}\\
Azure is a comprehensive cloud computing platform designed to streamline application development, deployment, and management. The platform provides a wide range of services, including virtual machines, databases, and AI tools, enabling scalable and secure solutions. Its resource management capabilities allow seamless integration across hybrid environments, while built-in DevOps tools enhance collaboration and automation.
\clearpage

\item[3] Task Distribution

\begin{table}[h]
\caption{Role Assignments}
\def\arraystretch{1.24} \small

\begin{tabular}{|p{1.2cm}|p{1.2cm}|p{5.4cm}|}
    \hline
    Tasks & Name & Descriptions \\
    \hline
    Project Manager & Kang DongHun & A Project Manager functions as the operational orchestrator responsible for planning, executing, and delivering projects within specified constraints of scope, time, and budget. Their role involves developing comprehensive project plans, establishing critical milestones, and implementing methodologies such as Agile or Waterfall to ensure efficient project delivery. They are accountable for resource allocation, timeline management, and budget control, utilizing project management tools and methodologies to track progress, identify bottlenecks, and maintain project momentum. Critical responsibilities include conducting regular status meetings, managing project documentation, tracking deliverables, and ensuring quality standards are met throughout the project lifecycle. Their success is measured through project completion metrics, team performance, and adherence to initial project parameters, requiring strong leadership skills and the ability to adapt to changing project demands while maintaining team cohesion and project focus.  \\ 
    \hline
    Frontend Developer & Pyo \par JunSeong, \par Bae \par Hyejin & Frontend developers utilize languages like React Native and TypeScript to create applications. They are responsible for designing the interfaces that users interact with, such as tapping buttons and swiping through screens. Their primary objective is to create a user experience that is both accessible and engaging, while adhering to the specified design. Additionally, frontend developers are responsible for transferring user-entered information to the backend developers. The reason for having three frontend developers is that two of them write code for each screen, while the third developer reviews and optimizes the code for the screens that users see. This organizational structure requires effective teamwork, clear role allocation, excellent communication skills, and collaborative synergy. \\
    \hline
    Backend Developer & Kang DongHun,  Yang Byeong \par Hyun & Backend developers are responsible for designing the database and application architecture, as well as writing the APIs used by frontend developers. When working with APIs, backend developers need to be able to receive information from application users through the frontend and provide the correct return value to the API. \\
    \hline
\end{tabular}
\end{table}

\begin{table}
\def\arraystretch{1.24} \small 

\begin{tabular}{|p{1.2cm}|p{1.2cm}|p{5.2cm}|}
    \hline
    Backend Developer & Kang DongHun,  Yang Byeong \par Hyun & They also need to design APIs that interact with the backend to leverage generative AI and machine learning features, and make them accessible to application users. This role requires a strong understanding of the central database and software structure, and ensuring that software development aligns with that structure.moment \\ 
    \hline
    UI-UX Designer & Pyo \par JunSeong, \par Bae \par Hyejin & The UI-UX designer, using Figma, is responsible for determining how the application screens are presented to users. This role involves deciding which screens will be more engaging and comfortable for users to use. As a UI-UX designer, the goal is to create a design that keeps users engaged and encourages them to return to the application. Once the UI-UX decisions are finalized, they can be communicated to the front-end developers \\ 
    \hline
    AI Developer & Pyo \par JunSeong, Yang Byeong \par Hyun & A machine learning software developer works with algorithms, data, and artificial intelligence. Their role involves researching, building, and designing artificial intelligence software specifically for machine learning purposes. They primarily focus on applying artificial intelligence systems to various applications. The responsibilities of this role include collecting, cleaning, and preprocessing data to extract meaningful value. They then use this data to train models and deploy them in software. Additionally, the machine learning software developer must appropriately implement machine learning algorithms into software functions, conduct experiments and tests of AI systems, and determine the most suitable models for the application’s functions. They are also responsible for designing and developing machine learning systems, as well as performing statistical analysis. \\
    \hline
    \end{tabular}
    \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ 

\end{table}

\clearpage


\section{SPECIFICATION}

\subsection{Splash Screen Page}
\begin{enumerate}
    \item[1.] Entry-splashing
    \begin{figure}[h]
        {\centering
        \hspace{4cm}
        \begin{minipage}{0.4\columnwidth}
    \includegraphics[width=\linewidth,height=7cm]
            {img/UIdesign/splash.png}
            \caption{Entry Splashing-Page}
        \end{minipage}}
    \end{figure}
    
    When the application is launched, the startup page should be displayed for a duration of 1 to 2 seconds to prevent an empty page from being shown while the application is loading its data. This ensures a smooth and visually appealing user experience during the app’s startup process. 
\end{enumerate}

\subsection{SignUp Page}

\begin{enumerate}
    \item[1.] Login-Page
    \begin{figure}[h]
        {\centering
        \hspace{4cm}
        \begin{minipage}{0.4\columnwidth}
            \includegraphics[width=\linewidth,height=7cm]{img/UIdesign/Login - Main.png}
            \caption{Login-Page}
        \end{minipage}}
    \end{figure}
    
    Users should be able to use the following features in the login page: Sign Up, Log In, Reset Password, SNS Login, and Language Change. \\
\end{enumerate}

    
\begin{enumerate}
    \item[2.] Sign Up-Phone Number
    \begin{figure}[h]
        {\centering
        \hspace{4cm}
        \begin{minipage}{0.4\columnwidth}
            \includegraphics[width=\linewidth]{img/UIdesign/Sign Up - Name and Birthdate}
            \caption{Sign Up Page}
        \end{minipage}}
    \end{figure}
    
    Users are required to enter their phone number. The phone number will serve as the user’s ID during the login process after registration. The validity of the phone number should be verified through the authentication system of the mobile service provider. \\ 
\end{enumerate}

\begin{enumerate}
    \item[3.] Sign Up-Password
    
    Users must enter a password. The password should be at least 8 characters long and must contain a combination of at least 3 of the following: uppercase letters, lowercase letters, numbers, and special characters. When the user enters their desired password, it is displayed in the form of ‘****’ on the screen, with each condition changing color to green when it is satisfied, and red when it is not. \\ 
\end{enumerate}

\begin{enumerate}
    \item[4.] Sign Up-Name and Birthdate
    
    Users must enter their name and date of birth. The date of birth should be entered in the ‘YY/MM/DD’ format, and gender will be verified based on the first digit of the resident registration number. \\ 
\end{enumerate}

\clearpage

\begin{enumerate}
    \item[5.] Sign\hspace{0.5em}Up-Preventing\hspace{0.5em}Duplicated PhoneNumber
    \begin{figure}[h]
        {\centering
        \hspace{4cm}
        \begin{minipage}{0.4\columnwidth}
        \includegraphics[width=\linewidth,height=7cm]{img/UIdesign/Sign Up - Preventing Duplicated.png}
            \caption{Sign Up - Preventing Duplicated Phone Number}
        \end{minipage}}
    \end{figure}
    \\ Registration with duplicate phone numbers must be prevented. Attempting to register with a phone number that is already in use should not be allowed. \\ 
\end{enumerate}

\begin{enumerate}
    \item[6.] Sign Up-Registration Completed
    \begin{figure}[h]
        {\centering
        \hspace{4cm}
        \begin{minipage}{0.4\columnwidth}
            \includegraphics[width=\linewidth,height=6cm]{img/UIdesign/Sign Up - Registration Completed.png}
            \caption{Sign Up - Registration Completed}
        \end{minipage}}
    \end{figure}
    
    Upon successful registration, a notification should be displayed to the user, and they should be automatically redirected to the login process. If the phone number is already registered, the screen displays existing account’s information including phone number and registering date.
\end{enumerate}

\subsection{Login Page}

\begin{enumerate}
    \item[1.] Login-Types
    \begin{figure}[h]
        {\centering
        \hspace{4cm}
        \begin{minipage}{0.4\columnwidth}
        \includegraphics[width=\linewidth,height=7cm]{img/UIdesign/Login - Main.png}
            \caption{Login-Types}
        \end{minipage}}
    \end{figure}
    
    Users should be able to log in using two types of login methods: (1) Local login via ALIVE membership, (2) SNS login via social media integration. \\ 
\end{enumerate}

\begin{enumerate}
    \item[2.] Login-Local Success

    If the ID and password entered by the user exist in the member database, the user will successfully log in and be directed to the main page. \\
\end{enumerate}

\begin{enumerate}
    \item[3.] Login-Local Failed
    \begin{figure}[h]
        {\centering
        \hspace{4cm}
        \begin{minipage}{0.4\columnwidth}
            \includegraphics[width=\linewidth,height=7cm]{img/UIdesign/Login - Local Failed.png}
            \caption{Login - Local Failed}
        \end{minipage}}
    \end{figure}
    
    If the user enters their ID and password, but either the ID or the password is incorrect or the user does not exist in the member database, a popup window will request the user to check their ID and password again. \\ 
\end{enumerate}

\begin{enumerate}
    \item[4.] Login-SNS Login
    
    The system utilizes SNS registration APIs such as Google, Naver, Kakao, and more. Users should be able to conveniently log in through these platforms. \\ 
\end{enumerate}

\begin{enumerate}
    \item[5.] Login-MyLG Login
    
    The system utilizes registration through MyLG. Users should be able to conveniently log in through these platforms. \\ 
\end{enumerate}

\begin{enumerate}
    \item[6.] Login-Password Reset Authentication
    \begin{figure}[h]
        {\centering
        \hspace{4cm}
        \begin{minipage}{0.4\columnwidth}
            \includegraphics[width=\linewidth]{img/UIdesign/Login - New Password.png}
            \caption{Password Reset - Authentication}
        \end{minipage}}
    \end{figure}
    
    The system should offer users guidance on setting a new password through carrier-based verification. Upon successful carrier authentication, users will be directed to the ‘Password Reset’ page; in case of failure, they will return to this page. \\ \\ \\ \\ \\ \\ \\ 
    
\end{enumerate}



\begin{enumerate}
    \item[7.] Login-New Password
    \begin{figure}[h]
        \centering
        \begin{minipage}{0.4\columnwidth}
            \includegraphics[width=\linewidth, keepaspectratio]{img/UIdesign/Login - New Password-1.png}
            \caption{New Password Failed}
        \end{minipage}
        \hfill
        \begin{minipage}{0.4\columnwidth}
            \includegraphics[width=\linewidth, keepaspectratio]{img/UIdesign/Login - New Password-2.png}
            \caption{New Password Success}
        \end{minipage}
    \end{figure}
    
    When setting a new password, users should be provided with appropriate security requirements, such as a combination of at least 8 characters, including at least three of uppercase letters, lowercase letters, numbers, and special characters.
\end{enumerate}

    
    

\subsection{Home Page}

\begin{enumerate}
    \item[1.] Default-Not Imported
    \begin{figure}[h]
        {\centering
        \hspace{4cm}
        \begin{minipage}{0.4\columnwidth}
            \includegraphics[width=\linewidth]{img/UIdesign/Home - Main.png}
            \caption{Default - Not Imported}
        \end{minipage}}
    \end{figure}
    
    System must initialize with import options when no devices are registered. System should display two primary action buttons: 'Import ThinQ' and 'Import Directly' in the main interface. These buttons must remain prominently visible until initial device registration is completed. \\ 
\end{enumerate}

\begin{enumerate}
    \item[2.] Import ThinQ
    \begin{figure}[h]
        {\centering
        \hspace{4cm}
        \begin{minipage}{0.4\columnwidth}
            \includegraphics[width=\linewidth]{}
            \caption{Import ThinQ}
        \end{minipage}}
    \end{figure}
    
    When users tap the Import ThinQ button, a connection popup should immediately appear on screen. The system should then automatically initiate ThinQ service connection while displaying a loading indicator to show progress. Upon completion, the system must show either a success or failure message to inform the user of the connection status. \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\
\end{enumerate}

\begin{enumerate}
    \item[3.] Import Directly
    \begin{figure}[h]
        {\centering
        \hspace{4cm}
        \begin{minipage}{0.4\columnwidth}
            \includegraphics[width=\linewidth]{img/UIdesign/Home - Register Appliances Directly.png}
            \caption{Import Directly}
        \end{minipage}}
    \end{figure}
    
    When users select the Import Directly option, the system should display a modal popup presenting two distinct import methods: QR scanning and Wi-Fi/Bluetooth connection. \\ 
\end{enumerate}

\begin{enumerate}
    \item[4.] Import Directly-QR
    
    Upon selecting the QR method, the system should first request camera permissions if not previously granted. The QR scanner should immediately open, displaying a clear scanning area in the viewfinder. The system should display appropriate error messages for invalid or unrecognized QR codes. \\ 
\end{enumerate}

\begin{enumerate}
    \item[5.] Import Directly-WiFi or Bluetooth
    
    When users choose the WiFi/Bluetooth import method, the system should check and request any necessary device permissions. The interface should display a list of available devices for connection, clearly indicating the connection status throughout the process. Users should be provided with clear, step-by-step connection instructions to ensure successful device pairing.
\end{enumerate}

\clearpage

\begin{enumerate}
    \item[6.] Entire Chat
    \begin{figure}[h]
        {\centering
        \hspace{4cm}
        \begin{minipage}{0.4\columnwidth}
            \includegraphics[width=\linewidth,height=7cm]{img/UIdesign/Home - Main-2.png}
            \caption{Entire Chat}
        \end{minipage}}
    \end{figure}    
    The system should display the main chat room interface that includes all connected appliances. The header section must contain four essential buttons: a chat room selection toggle for switching between different chat rooms, a create chat room button for establishing new chat spaces, a notification button for accessing system alerts, and an others button for additional settings. \\
\end{enumerate}

\begin{enumerate}
    \item[7.] Select ChatRoom
    \begin{figure}[h]
        \centering
        \begin{minipage}{0.4\columnwidth}
            \includegraphics[width=\linewidth, keepaspectratio]{img/UIdesign/Home - Create-ChatRoom - Select None.png}
            \caption{Select ChatRoom - None}
        \end{minipage}
        \hfill
        \begin{minipage}{0.4\columnwidth}
            \includegraphics[width=\linewidth, keepaspectratio]{img/UIdesign/Home - Create-ChatRoom - Select Complete.png}
            \caption{Select ChatRoom - Available}
        \end{minipage}
    \end{figure}
    
    The system should allow users to navigate between different appliance chat rooms through the chat room toggle button. Users should be presented with a list of available chat rooms and can easily switch to their desired room. \\
\end{enumerate}

\begin{enumerate}
    \item[8.] Create ChatRoom
    \begin{figure}[h]
        {\centering
        \hspace{4cm}
        \begin{minipage}{0.4\columnwidth}
            \includegraphics[width=\linewidth,height=7cm]{img/UIdesign/Home - Create-ChatRoom - Set Name Complete.png}
            \caption{Create ChatRoom}
        \end{minipage}}
    \end{figure}
    
    When users tap the create chat room button, the system should display a comprehensive list of all connected appliances. Users can assign a chat room name with a maximum of 10 letters.\\
\end{enumerate}

\begin{enumerate}
    \item[9.] Notice
    \begin{figure}[h]
        {\centering
        \hspace{4cm}
        \begin{minipage}{0.4\columnwidth}
            \includegraphics[width=\linewidth,height=7cm]{img/UIdesign/My Page - Alram-1.png}
            \caption{Notice}
        \end{minipage}}
    \end{figure}
    
    The notification system should provide users with important app alerts and updates. A red dot indicator must appear on the notification icon when there are unread alerts, ensuring users are aware of new notifications. Upon clicking the notification button, the system should display a chronological list of all notifications, distinguishing between read and unread messages.\\
\end{enumerate}

\begin{enumerate}
    \item[10.] Others-Edit
    \begin{figure}[h]
        {\centering
        \hspace{4cm}
        \begin{minipage}{0.4\columnwidth}
            \includegraphics[width=\linewidth,,height=7cm ]{img/UIdesign/Home - _Chat - Side.png}
            \caption{Others-Edit}
        \end{minipage}}
    \end{figure}
    
    Users should be able to edit chat room information. They can rename chat rooms, and add or delete appliances. The minimum number of appliances in a chat room must be at least one. Users should also be able to toggle the power status (ON/OFF) of devices in the chat room. Only active (ON) devices can receive commands and participate in interactions. \\
\end{enumerate}

\begin{enumerate}
    \item[11.] Chat-Appliance-Tag
    
    Users should be able to tag and command home appliances within chat rooms using the ``@" symbol (e.g., ``@WashingMachine"). The system must provide real-time validation of device availability. \\ \\ \\ \\ \\ \\ \\
\end{enumerate}

\begin{enumerate}
    \item[12.] Voice-Command
    \begin{figure}[h]
        {\centering
        \hspace{4cm}
        \begin{minipage}{0.4\columnwidth}
            \includegraphics[width=\linewidth]{img/UIdesign/Home - _Chat - MIC.png}
            \caption{Voice Command}
        \end{minipage}}
    \end{figure}
    
    Users should be able to communicate with their appliances through voice commands. For example, users can say, ``Air conditioner, I'm feeling a bit warm," and receive conversational responses about adjusting the temperature settings. \\
\end{enumerate}

\begin{enumerate}
    \item[13.] Command-Verification
    \begin{figure}[h]
        {\centering
        \hspace{4cm}
        \begin{minipage}{0.4\columnwidth}
            \includegraphics[width=\linewidth]{img/UIdesign/Home - _Chat - CV.png}
            \caption{Command Verification}
        \end{minipage}}
    \end{figure}
    
    The appliance should respond within the chat with a message asking if the user would like to perform the suggested action. There should be small ``Confirm" (O) and ``Cancel" (X) icons for user approval or rejection. The appliance will only execute the action after the user confirms. \\ 
\end{enumerate}

\begin{enumerate}
    \item[14.] ChatRoom-Search
    
    Users should be able to search for past conversations within the chat room by typing keywords or device names. The search results should display relevant chat history with context on when the conversations occurred. \\ 
\end{enumerate}

\begin{enumerate}
    \item[15.] ChatRoom-Exit
    \begin{figure}[h]
        {\centering
        \hspace{4cm}
        \begin{minipage}{0.4\columnwidth}
            \includegraphics[width=\linewidth]{img/UIdesign/Home - _Chat - Exit.png}
            \caption{ChatRoom Exit}
        \end{minipage}}
    \end{figure}
    \\ Users should be able to delete an appliance chat room they have created. Upon deletion, the user will be prompted to confirm, and all contents will be permanently removed. Users should have the option to archive the chat history before deletion if desired.
\end{enumerate}

\clearpage

\subsection{Appliance Page}
    \begin{enumerate}
    \item[1.] Appliances-Default
    \begin{figure}[h]
        {\centering
        \hspace{4cm}
        \begin{minipage}{0.4\columnwidth}
            \includegraphics[width=\linewidth,height=9cm]{img/UIdesign/Appliance-Default.png}
            \caption{Appliances Default}
        \end{minipage}}
    \end{figure}

    The system should display a comprehensive list of all connected appliances, providing users with a clear overview of their smart home ecosystem. Each appliance entry should show essential information, including connection status, device name, and current operational status. The list must be updated whenever device status changes or new devices are added. \\ 
\end{enumerate}

\begin{enumerate}
    \item[2.] Appliances-Sync
    \begin{figure}[h]
        {\centering
        \hspace{4cm}
        \begin{minipage}{0.2\columnwidth}
            \includegraphics[width=\linewidth]{img/UIdesign/Appliance-sync.png}
            \captionsetup{width=2.5\linewidth}
            \caption{Appliances Sync}
        \end{minipage}}
    \end{figure}

    When users activate the sync button, the system should initiate synchronization with ThinQ services and the application list in the internal app to update the appliance list. Upon successful synchronization of new devices, the system must automatically add them to the entire chat room and display a welcome message in the format ``Appliance [Name] joined default chat room". The synchronization process should show a clear progress indicator and confirmation of completion or any errors encountered. \\
\end{enumerate}

\begin{enumerate}
    \item[3.] Appliances-Import
    \begin{figure}[h]
        {\centering
        \hspace{4cm}
        \begin{minipage}{0.2\columnwidth}
            \includegraphics[width=\linewidth]{img/UIdesign/Appliance - import.png}
            \captionsetup{width=2.5\linewidth}
        \caption{Appliances Import} % 강제로 한 줄 유지
        \end{minipage}}
    \end{figure}

    The appliance import functionality should mirror the import options available on the main page, providing users with two distinct import methods: QR code scanning and WiFi/Bluetooth connection. For QR scanning, the system must activate the device camera and provide clear scanning guidance. The WiFi/Bluetooth method should display available devices and guide users through the connection process with clear step-by-step instructions. \\ 
\end{enumerate}

\begin{enumerate}
    \item[4.] Applications-Detail
    \begin{figure}[h]
        {\centering
        \hspace{4cm}
        \begin{minipage}{0.4\columnwidth}
            \includegraphics[width=\linewidth,height=9cm]{img/UIdesign/Appliance-Lists - Main.png}
            \caption{Applications Detail}
        \end{minipage}}
    \end{figure}

    When users select an appliance from the list, the system should display a detailed information page including comprehensive usage statistics and interaction history. This detail view must show a list of participating chat rooms, total operation time, user feedback and ratings, and a chronological history of interactions with other appliances. The interface should present this information in clearly organized sections, allowing users to easily track and analyze their appliance usage patterns and performance history. \\ 
\end{enumerate}

    
\subsection{MyPage}

\begin{enumerate}
    \item[1.] Mypage-Password Change
    \begin{figure}[h]
        {\centering
        \hspace{4cm}
        \begin{minipage}{0.4\columnwidth}
            \includegraphics[width=\linewidth]{img/UIdesign/Password_Change.png}
            \caption{Password Change}
        \end{minipage}}
    \end{figure}

    Users must enter their current password to verify their identity before changing it to a new one. The new password must be at least 8 characters long, including special characters. If the new password is identical to the current one, a notification will inform the user that it cannot be reused. Passwords must include at least 3 of the following: uppercase letters, lowercase letters, numbers, and special characters. \\ \\ \\ \\
\end{enumerate}

\begin{enumerate}
    \item[2.] Mypage-Profile Picture Update
    \begin{figure}[h]
        {\centering
        \hspace{4cm}
        \begin{minipage}{0.4\columnwidth}
            \includegraphics[width=\linewidth]{img/UIdesign/Profile_Picture_Update.png}
            \caption{Profile Picture Update}
        \end{minipage}}
    \end{figure}

    Users can upload a new profile picture or select from existing images on their device. The updated profile picture will appear throughout the app. \\
\end{enumerate}

\begin{enumerate}
    \item[3.] Mypage-Notification Settings
    \begin{figure}[h]
        {\centering
        \hspace{4cm}
        \begin{minipage}{0.4\columnwidth}
            \includegraphics[width=\linewidth]{img/UIdesign/My Page - Alram.png}
            \caption{Notification Settings}
        \end{minipage}}
    \end{figure}

    Users can enable or disable notifications for app events like messages, updates, and alerts. Preferences are saved immediately. \\ 
\end{enumerate}

\begin{enumerate}
    \item[4.] Mypage-App Version Check
    \begin{figure}[h]
        {\centering
        \hspace{4cm}
        \begin{minipage}{0.4\columnwidth}
            \includegraphics[width=\linewidth]{img/UIdesign/My Page - Version_check.png}
            \caption{App Version Check}
        \end{minipage}}
    \end{figure}

    The app displays the current version installed on the user's device. Users can check if they have the latest version. \\
\end{enumerate}

\begin{enumerate}
    \item[5.] Mypage-Language Settings
    \begin{figure}[h]
        {\centering
        \hspace{4cm}
        \begin{minipage}{0.4\columnwidth}
            \includegraphics[width=\linewidth]{img/UIdesign/My Page - Language}
            \caption{Language Settings}
        \end{minipage}}
    \end{figure}

    Users can choose their preferred language for the app interface, which updates immediately upon selection. \\ \\
\end{enumerate}

\begin{enumerate}
    \item[6.] Mypage-Personal Information
    \begin{figure}[h]
        {\centering
        \hspace{4cm}
        \begin{minipage}{0.4\columnwidth}
            \includegraphics[width=\linewidth]{img/UIdesign/My Page - Personal_Info.png}
            \caption{Personal Information}
        \end{minipage}}
    \end{figure}

    Users can view personal details like carrier, phone number, and registration date, and set up simplified login options.
\end{enumerate}


\subsection{Result Page}
    \begin{enumerate}
        \item[1.] ResultAnalysis-Calendar View
        \begin{figure}[h]
        {\centering
        \hspace{4cm}
        \begin{minipage}{0.4\columnwidth}
            \includegraphics[width=\linewidth]{img/UIdesign/_Scenario Anlaysis - Main.png}
            \caption{Result Calender}
        \end{minipage}}
    \end{figure}
        \\ The Result Analysis page should display a calendar-based view that shows all interaction outcomes from appliance conversations. Each calendar date must present the specific choices and results that were provided to users during their interactions. The system should maintain a comprehensive record of all interactions, displaying them in a chronological format that allows users to easily navigate through their history.\\
    \end{enumerate}
    
    \begin{enumerate}
        \item[2.] ResultAnalysis-Data 
        Presentation
        \begin{figure}[h]
        {\centering
        \hspace{4cm}
        \begin{minipage}{0.4\columnwidth}
            \includegraphics[width=\linewidth]{img/UIdesign/_Scenario Anlaysis - Detail (mod).png}
            \caption{ResultAnalysis-Data }
        \end{minipage}}
    \end{figure}
        \\ The system must present all interaction data in an organized and easy-to-understand format within the calendar view. Each date with recorded interactions should be clearly marked, and users should be able to view detailed information about the interactions that occurred on any specific date. The interface should allow users to track patterns in their appliance usage and decision-making over time, providing valuable insights into their interaction history. This calendar-based presentation format ensures that users can efficiently review and analyze their past interactions, understanding how the system responded to different situations across various timeframes. \\ \\ \\ \\ \\ \\ 
    \end{enumerate}

\section{ARCHITECTURE DESIGN}
\subsection{Overall Architecture}

\begin{figure}[h]
\centering   
\includegraphics[width=1\columnwidth]{img/architecture/OA.png}
\caption{Overall Architecture}
\end{figure}

\hspace{0.7em} ALIVE is composed of four main modules: the Frontend, the Backend (Main Server), the Chat Server (Sendbird), and the AI Server, each playing a distinct role in delivering a seamless user experience. \\

\hspace{0.7em} The first module “Frontend.”  is built using React-native with TypeScript, JavaScript and serves as the user interface. It allows users to interact with the system by providing features such as data retrieval, input, and chat functionality, while also displaying AI-generated results. The frontend communicates with the backend server via APIs, connects to the chat server using WebSocket or the Sendbird SDK for real-time messaging, and visualizes responses from the AI server. \\


\hspace{0.7em} The second module, “Backend (Main Server)”, implemented using Spring Boot and Kotlin, acts as the core processing unit of the system. It manages user authentication, processes chat-related operations such as creating and managing chat rooms, channels, and channel users, and routes requests to the appropriate components like the database, AI server, or chat server. Additionally, it provides APIs to the frontend and ensures smooth data management through integration with Supabase and PostgreSQL for storing user information, logs, and chat-related data. \\

\hspace{0.7em} The third module “Chat Server” powered by Sendbird, facilitates real-time messaging between users. It supports one-on-one and group chats, manages message storage, and provides notifications and user status updates. The chat server connects with the frontend through the Sendbird SDK, ensuring reliable and real-time communication. It also synchronizes chat data with the backend and database as needed. \\ 

The fourth module “AI Server” is implemented using FastAPI. It is deployed on Azure and integrates with OpenAI to provide intelligent responses. Its primary function is to generate contextually appropriate replies tailored for conversations in chat rooms involving smart appliances. By leveraging OpenAI's generative AI, the server ensures that the responses align with the unique interactions and requirements of smart device communication. \\

\subsection{Directory Organization}

\begin{table}[h]
\caption{DIRECTORY-ORGANIZATION-FRONTEND-1}
\def\arraystretch{1.24} \small
    \begin{tabular}{|p{3.7cm}|p{4.1cm}|}
\hline
        Directory & File Name \\ \hline
          ALIVE/frontend/src/app  & \_layout.tsx \par +html.tsx \par +not-found.tsx \par index.tsx 
          \\ \hline
          
          ALIVE/frontend/src/app/ \par (tabs) \par  & \_layout.tsx \par analysis.tsx \par inbox.tsx \par index.tsx \par list.tsx \par profile.tsx
          \\ \hline
          
          ALIVE/frontend/src/app/ \par (tabs)/appDetail \par  & appKey.tsx
          \\ \hline
          
          ALIVE/frontend/src/app/ \par (tabs)/chat \par  & [channel\_url].tsx \par create\_chat\_name.tsx \par create\_chat\_room.tsx \par index.tsx
          \\ \hline
          
          ALIVE/frontend/src/app/ \par (tabs)/exeAnalysis \par  & [exeKey].tsx
          \\ \hline
          
          ALIVE/frontend/src/ \par components/analysis \par  & ContentBox.tsx \par CustomCalendar.tsx \par DatePickerModal.tsx \par energyCard.tsx \par RecordsList.tsx
          \\ \hline
          
          ALIVE/frontend/src/ \par components/chat \par  & ChatBubble.tsx \par ChatContainer.tsx \par ChatDrawer.tsx \par ChatInput.tsx \par ChatRoomCard.tsx
          \\ \hline

    \end{tabular}
\end{table}

\begin{table}[h]
\caption{DIRECTORY-ORGANIZATION-FRONTEND-2}
\def\arraystretch{1.24} \small
    \begin{tabular}{|p{3.7cm}|p{4.1cm}|}
\hline
        Directory & File Name \\ \hline
          ALIVE/frontend/src/ \par components/common \par  & AppBar.tsx \par Bold.tsx \par Button.tsx \par ClickBox.tsx \par DeviceCard.tsx \par InputField.tsx \par Loading.tsx \par ThemedText.tsx \par ThemedView.tsx
          \\ \hline
          
          ALIVE/frontend/src/ \par components/icons \par  & Analysis.tsx \par Bell.tsx \par BellOff.tsx \par DotsCircle.tsx \par Home.tsx \par MoreVertical.tsx \par Plus.tsx \par Profile.tsx \par Sync.tsx \par Wallet.tsx
          \\ \hline
          
          ALIVE/frontend/src/ \par components/icons/devices \par  & AirConditioner.tsx \par AirPurifier.tsx \par Cleaner.tsx \par Dryer.tsx \par Refrigerator.tsx \par Tv.tsx \par WashingMachine.tsx
          \\ \hline
          
          ALIVE/frontend/src/ \par components/list \par  & deviceList.tsx \par ExeLogBox.tsx \par ParticipatingChatRoom.tsx
          \\ \hline
          
          ALIVE/frontend/src/ \par components/login \par  & toggle.tsx
          \\ \hline
          
          ALIVE/frontend/src/ \par components/navigation \par  & TabBarIcon.tsx
          \\ \hline
          
          ALIVE/frontend/src/hooks \par  & useColorScheme.ts \par useColorScheme.web.ts \par useLogin.ts \par useModal.ts \par useThemeColor.ts
          \\ \hline
          
          ALIVE/frontend/src/service \par  & auth.service.ts \par axios-instance.ts \par channel.service.ts \par chat.service.ts \par device.service.ts \par message.service.ts
          \\ \hline
          
          ALIVE/frontend/src/stores \par  &   useDeviceStore.ts \par useUserStore.ts
          \\ \hline
          
          ALIVE/frontend/src/types \par  & chat.ts \par device.ts \par icon.ts \par images.d.ts \par record.types.ts 
          \\ \hline
          
          ALIVE/frontend/src/utils \par  & calendar.ts \par date.ts
          \\ \hline
    \end{tabular}
\end{table}

\clearpage

\begin{table}[h!]
\caption{DIRECTORY-ORGANIZATION-BACKEND}
\def\arraystretch{1.24} \small
    \begin{tabular}{|p{3.9cm}|p{4.4cm}|}
        \hline
        Directory & File Name \\ \hline
          ALIVE/backend/src/main/ \par kotlin/com/example/demo & Application.kt  \\ \hline
          
          ALIVE/backend/src/main/ \par kotlin/com/example/demo/ \par config & AppConfig.kt \par GlobalExceptionHandler.kt \par SecurityConfig.kt \par SendbirdConfig.kt\\ \hline
          
          ALIVE/backend/src/main/ \par kotlin/com/example/demo/ \par controller & AuthController.kt \par ChannelController.kt \par DeviceController.kt \par DeviceUsageRecordController.kt \par UserController.kt \\ \hline
          
          ALIVE/backend/src/main/ \par kotlin/com/example/demo/ \par controller/sendbird & SendbirdChannelController.kt \par SendbirdMessageController.kt \par SendbirdUserController.kt \\ \hline
          
          ALIVE/backend/src/main/ \par kotlin/com/example/demo/ \par repository & ChannelDeviceRepository.kt \par ChannelRepository.kt \par DeviceRepository.kt \par DeviceUsageRecordRepository.kt \par UserDeviceRepository.kt \par UserRepository.kt \\ \hline
          
          ALIVE/backend/src/main/ \par kotlin/com/example/demo/ \par service & ChannelService.kt \par DeviceService.kt \par DeviceUsageRecordService.kt \par UserService.kt \\ \hline
          
          ALIVE/backend/src/main/ \par kotlin/com/example/demo/ \par service/sendbird & SendbirdChannelService.kt \par SendbirdMessageService.kt \par SendbirdUserService.kt \\ \hline
          
          ALIVE/backend/src/main/ \par kotlin/com/example/demo/ \par model & Channel.kt \par ChannelDevice.kt \par Device.kt \par DeviceCategory.kt \par DeviceUsageRecord.kt \par User.kt \par UserDevice.kt \\ \hline
          
          ALIVE/backend/src/main/ \par kotlin/com/example/demo/ \par dto & ActionDTO.kt \par LoginRequestDTO.kt \par UserDeviceResponseDTO.kt \\ \hline

          ALIVE/backend/src/main/ \par kotlin/com/example/demo/ \par dto/channel & ChannelDTO.kt \par ChannelDeviceDTO.kt \par ChannelResponseDTO.kt \par CreateChannelRequestDTO.kt \\ \hline
          
          
          ALIVE/backend/src/main/ \par kotlin/com/example/demo/ \par dto/sendbird &  QueryMessagesRequest.kt \par  SendMessageRequest.kt \par SendbirdChannelCreateRequest.kt \par SendbirdUserCreateRequest.kt \par SendbirdUserCreateResponse.kt
         \par SendbirdUserInviteRequest.kt \\ \hline
          
          ALIVE/backend/src/main/ \par kotlin/com/example/demo/ \par dto/user & UserCreateRequestDTO.kt \par UserDTO.kt \par UserInviteRequestDTO.kt \par UserResponseDTO.kt \\ \hline

          ALIVE/backend/src/main/ \par kotlin/com/example/demo/ \par exception & DeviceNotFoundInChannel \par Exception.kt\par DeviceNotInProgressException.kt \par UserDeviceNotFoundException.kt \par UserNotFoundException.kt \\ \hline

          ALIVE/backend/src/main/ \par kotlin/com/example/demo/util & SendbirdApiHelper.kt \\ \hline
          
	\end{tabular}
\end{table}

\begin{table}[h]
\caption{DIRECTORY-ORGANIZATION-AI}
\def\arraystretch{1.24} \small
    \begin{tabular}{|p{3.9cm}|p{4cm}|}
\hline
        Directory & File Name \\ \hline
          ALIVE/AI \par  & requirements.txt \\ \hline
          ALIVE/AI/app \par  & \_\_init\_\_.py \par main.py \par retriever.py \\ \hline
          ALIVE/AI/app/api \par  & routes.py \\ \hline
          ALIVE/AI/app/data \par  & create\_dataset\_azure.py \par create\_dataset\_openai.py \par dataset.json \par domain\_slots.json  \\ \hline
          ALIVE/AI/app/helper \par  &  turn\_data\_to\_str.py \\ \hline
          ALIVE/AI/app/prompts \par  & system\_prompt.txt \par table\_prompt.txt \\ \hline
        
    \end{tabular}
\end{table}


\subsection{Module 1: Frontend}
\begin{enumerate}
    \item Purpose\\
    The Frontend Module of ALIVE serves as the client-facing interface, enabling users to interact with the system seamlessly. It handles the display of data, user input, and interactions, ensuring a user-friendly experience across devices. Built using modern web technologies, the frontend communicates with the backend, AI server, and chat server to present real-time data, manage user settings, and facilitate smart device interactions within chat rooms. \\ 
    \item Functionality \\
    The frontend provides a range of features, including user authentication, profile management, appliance list views, and device usage analysis presented in calendar and card formats. It enables real-time chat functionality for interacting with smart appliances and supports dynamic routing for detailed views such as chat rooms and execution analysis. Additionally, it includes reusable components like buttons, modals, and charts for efficient UI development. Hooks and services are used to manage states and make API calls for authentication, device control, and messaging, ensuring smooth communication with other modules. \\
    
    \item Location of source code:\\ https://github.com/SWE-ALIVE/frontend \\
    \item Class component
        \item[-] \_layout.tsx : This is the main layout component that wraps the entire application.\\
        \item[-] +html.tsx : This is a file that defines the HTML template structure.\\
        \item[-] +not-found.tsx : This is a file that handles 404 error page rendering.\\
        \item[-] index.tsx : This is the main entry page of the application.\\
        
        \item[-] \_layout.tsx : This is a file that defines the layout structure for tabs. \\
        \item[-] profile.tsx : This is a file for user profile management.\\
        \item[-] list.tsx : This is a file for displaying appliance list views.\\
        \item[-] inbox.tsx : This is a file for handling alarm inbox functionality.\\
        \item[-] analysis.tsx : This is a file for displaying application analysis records in calendar format.\\

        \item[-] appDetail/[appKey].tsx : This is a dynamic route file for showing detailed application information.\\
        
        \item[-] [channel\_url].tsx : This is a dynamic route file for chat room functionality.\\
        
        \item[-] exeAnalysis/[exeKey].tsx : This is a dynamic route file for execution analysis views.\\
        \item[-] ContentBox.tsx : This is a component for displaying analysis content in a structured format.\\
        \item[-] RecordsList.tsx : This is a component for showing records in a list format.\\
        \item[-] energyCard.tsx : This is a component for displaying energy usage information. \\
        \item[-] DatePickerModal.tsx : This is a modal component for date selection.\\
        \item[-] analysisContentBox.tsx : This is a component for displaying analysis content in a structured format.\\
        \item[-] CustomCalendar.tsx : This is a component that provides calendar functionality.\\
        
        \item[-] ChatBubble.tsx : This is a component for displaying chat messages. \\
        \item[-] ChatDrawer.tsx : This is a drawer component for chat room side bar. \\
        \item[-] ChatInput.tsx : This is a component for chat message input.\\
        \item[-] ChatRoomCard.tsx : This is a component for displaying chat room information. \\
        \item[-] ChatContainer.tsx : This is a container component for chat functionality.\\
        
        \item[-] AppBar.tsx : This is a component for the top application bar.\\
        \item[-] Button.tsx : This is a reusable button component.\\
        \item[-] InputField.tsx : This is a reusable input field component. \\
        \item[-] Loading.tsx : This is a component for displaying loading states.\\
        \item[-] ThemedText/View.tsx : These are components for theme-aware text and view rendering.\\
    
        \item[-] Analysis.tsx, Bell.tsx : These are files containing various icon components.\\

        \item[-] devices : This is a folder containing appliance-specific icons.\\
        \item[-] useColorScheme.ts: This is a hook for managing color scheme preferences. \\
        \item[-] useLogin.ts: This is a hook for handling login functionality. \\
        \item[-] useModal.ts: This is a hook for modal state management. \\
        \item[-] useThemeColor.ts: This is a hook for theme color management.\\
        \item[-] auth.service.ts: This is a file for authentication-related API calls. \\
        \item[-] channel.service.ts: This is a file for channel-related API calls. \\
        \item[-] chat.service.ts: This is a file for chat-related API calls. \\
        \item[-] device.service.ts: This is a file for device-related API calls. \\
        \item[-] message.service.ts: This is a file for message-related API calls. \\
        \item[-] useDeviceStore.ts: This is a file for managing device-related states. \\
        \item[-] useUserStore.ts: This is a file for managing user-related states. \\
        \item[-] chat.ts, device.ts, etc.: These are files containing various type definitions. \\
        \item[-] calendar.ts: This is a file containing calendar-related utilities. \\
        \item[-] date.ts: This is a file containing date handling utilities.\\
        
\end{enumerate}

\subsection{Module 2: Backend}
\begin{enumerate}
    \item Purpose\\
    The backend for ALIVE is responsible for managing the server-side operations and databases. It stores, processes, and manages data generated from user interactions on the client-side application and facilitates the retrieval of necessary information. The backend also ensures seamless communication between the frontend, chat server (Sendbird), and AI server. To implement the backend for ALIVE, we utilized Spring Boot with Kotlin for its modern syntax and compatibility. For data storage, we used Supabase and PostgreSQL, which ensure reliable and efficient data management. \\
    \item Functionality\\
    The ALIVE backend processes user requests from the frontend, chat server, or AI server, managing chatrooms, IoT device synchronization, and user settings. It logs actions in the database to ensure traceability and supports device communication, routine automation, and intelligent chat-based interactions. Additionally, it generates reports and synchronizes settings to deliver a seamless and scalable user experience. \\
    \item Location of source code:\\ https://github.com/SWE-ALIVE/backend \\ \\
    \item Class component
        \item[-] Application.kt : Entry point for launching the Spring Boot application. \\

        \item[-] config : Directory for configuration files and classes, such as application settings and beans.\\
        \item[-] AppConfig.kt : Contains general application-wide configuration and bean definitions.\\
        \item[-] GlobalExceptionHandler.kt : Handles exceptions globally across the application.\\
        \item[-] SecurityConfig.kt : Configures security settings, such as authentication and authorization.\\
        \item[-] SendbirdConfig.kt : Configures integration settings for the Sendbird chat service.\\
        
        \item[-] controller : Directory for handling incoming API requests and routing them to the appropriate services.\\
        \item[-] AuthController.kt : Manages authenticati-\\on-related endpoints, such as login and logout.\\
        \item[-] ChannelController.kt : Handles endpoints related to channel creation and management.\\
        \item[-] DeviceController.kt : Manages device-related operations, such as adding or removing IoT devices \\
        \item[-] DeviceUsageRecordController.kt : Handles endpoints for managing and retrieving device usage records.\\
        \item[-] UserController.kt : Manages user-related operations, such as profile updates and user information retrieval\\
        
        \item[-] service : Contains business logic for handling core application functionality.\\
        \item[-] ChannelService.kt : Handles business logic for channel management.
\\
        \item[-] DeviceService.kt : Manages IoT device-related operations.\\
        \item[-] DeviceUsageRecordService.kt : Handles Processes device usage records.\\
        \item[-] UserService.kt : Implements business logic for user management.\\
        
        \item[-] repository : Handles database interactions for various entities.\\
        \item[-] ChannelRepository.kt : Manages data access for channel entities.\\
        \item[-] ChannelDeviceRepository.kt : Handles data access for channel-device relationships.\\
        \item[-] DeviceRepository.kt : Manages database operations for IoT devices.\\
        \item[-] DeviceUsageRecordRepository.kt : Handles data access for device usage records.\\
        \item[-] UserDeviceRepository.kt : Manages user-device relationships in the database.\\
        \item[-] UserRepository.kt : Handles database interactions for user entities.\\
        
        \item[-] model : Defines the core data entities used throughout the application.\\
        \item[-] ChannelDevice.kt : Represents the relationship between channels and devices.\\
        \item[-] DeviceUsageRecord.kt : Represents records of IoT device usage.\\
        \item[-] UserDevice.kt : Represents the relationship between users and their devices.\\

        \item[-] dto : Contains Data Transfer Objects for handling requests and responses.\\
        \item[-] ActionDTO.kt : Represents data for specific actions performed by users or devices. \\
        \item[-] LoginRequestDTO.kt : Handles login request data from clients.\\
        \item[-] UserDeviceResponseDTO.kt : Represents response data for user-device relationships.\\
        
        \item[-] dto/sendbird : Contains Data Transfer Objects specifically for Sendbird API integration.\\
        \item[-] QueryMessagesRequest.kt : Represents a request to query messages from a Sendbird channel.\\
        \item[-] SendMessageRequest.kt : Handles data for sending messages to a Sendbird channel. \\
        \item[-] SendbirdUserCreateRequest.kt : Represents data for creating a new user in Sendbird.\\
        \item[-] SendbirdUserCreateResponse.kt : Represents the response data after creating a user in Sendbird.\\
        \item[-] SendbirdUserInviteRequest.kt : Handles data for inviting users to a Sendbird channel.\\
        
        \item[-] dto/channel : Contains Data Transfer Objects for managing channel-related operations.\\
        \item[-] CreateChannelRequestDTO.kt : Handles data for creating a new channel. \\
        \item[-] ChannelResponseDTO.kt : Represents response data for channel-related requests.\\
        \item[-] ChannelDeviceDTO.kt : Represents data for devices associated with a channel.\\
        
        \item[-] dto/user : Contains Data Transfer Objects for user-related operations. \\
        \item[-] UserCreateRequestDTO.kt : Handles data for creating a new user.\\
        \item[-] UserResponseDTO.kt : Represents response data for user-related requests.\\
        \item[-] UserInviteRequestDTO.kt : Handles data for inviting a user to a specific channel or group.\\
        
        \item[-] exception : Contains custom exceptions for handling application-specific errors.\\
        \item[-] DeviceNotFoundInChannel : Thrown when a device is not found in the specified channel. \\
        \item[-] Exception.kt : Base class for defining custom exceptions in the application.\\
        \item[-] DeviceNotInProgressException.kt : Thrown when a device is not in a valid progress state.\\
        \item[-] UserDeviceNotFoundException.kt : Thrown when a user-device relationship is not found. \\
        \item[-] UserNotFoundException.kt : Thrown when the specified user is not found.\\
        
        \item[-] util : Contains utility classes and helpers for reusable functionality. \\
        \item[-] SendbirdApiHelper.kt : Provides helper functions for interacting with the Sendbird API.\\
        
\end{enumerate}

\subsection{Module 3: AI}
\begin{enumerate}
    \item Purpose\\
    The AI module serves as the core of intelligent interactions within the ALIVE system. Its primary purpose is to process user inputs, generate context-aware responses, and handle dataset creation and interaction with AI models. By leveraging technologies such as FastAPI, Azure, and OpenAI, the AI module ensures real-time communication and provides dynamic, personalized outputs to enhance the user experience. \\
    \item Functionality\\
    The AI module interacts with the backend to process requests and utilizes OpenAI models to generate tailored, context-aware responses. It supports dataset creation using Azure and OpenAI APIs, manages predefined AI prompt templates, and handles natural language processing tasks. Additionally, it provides utilities for data preprocessing and model input preparation, ensuring efficient integration of AI services within the system. \\
    \item Location of source code:\\ https://github.com/SWE-ALIVE/AI \\
    \item Class component
        
        \item[-] app : Core application logic, including the entry point.\\
        \item[-] \_\_init\_\_.py : Initializes the app package for the AI server.\\
        \item[-] main.py : Serves as the entry point for the FastAPI server, defining the application’s startup configuration.\\
        \item[-] retriever.py : Implements logic for retrieving and processing data, such as querying data sources or preparing input for AI models.\\
        \item[-] routes.py : Defines the API endpoints for the AI server, managing requests and responses for client interactions.\\
        
        \item[-] app/data : Scripts and files for dataset creation and management.\\
        \item[-] create\_dataset\_azure.py : Generates datasets by interacting with Azure services.\\
        \item[-] create\_dataset\_openai.py : Creates datasets using OpenAI APIs for training or inference.\\
        \item[-] dataset.json : Stores preprocessed dataset information used by the AI server.\\
        \item[-] domain\_slots.json : Contains slot information for domain-specific AI interactions, helping structure conversational data.\\
        
        \item[-] app/helper : Utilities for data preprocessing.\\
        \item[-] turn\_data\_to\_str.py : A utility script to convert structured data into string format, facilitating easier processing or integration with models.\\
        
        \item[-] app/prompts : Predefined templates for AI prompts.\\
        \item[-] system\_prompt.txt : Stores the base system prompt for guiding AI interactions.\\
        \item[-] table\_prompt.txt : A predefined prompt template tailored for interpreting or generating table-based outputs.\\
\end{enumerate}


\section{AI SPECIFICATION}

\subsection{In-Context Learning for Few-Shot Dialogue State Tracking(ICL-DST)}

\begin{itemize}
    \item [1)] Introduction \\
Dialogue State Tracking (DST) is a crucial component in dialogue systems, responsible for tracking user requirements and determining subsequent actions. Traditional DST approaches require retraining the model each time a new domain is added, leading to high costs and inefficiency. To address these challenges, ICL-DST introduces a zero-shot and few-shot learning framework that leverages In-Context Learning by incorporating in-context examples into a pre-trained language model, enabling flexible prediction of dialogue states across new domains. \\ 
\end{itemize}

\begin{itemize}
    \item [2)] DST System Design \\
The ICL-DST system is designed to handle multi-domain scenarios, enabling the tracking and prediction of dialogue states for each domain. Each domain, such as user-appliance interactions or appliance-appliance communications, has a predefined set of slots like "appliance-name" or "appliance-status". The dialogue state is represented as a set of slot-value pairs, potentially spanning multiple domains. \\
\end{itemize}

\begin{itemize}
    \item [3)] DST Task Framing \\
Dialogue consists of a series of turns alternating between user utterances and system responses. The DST task is to predict the current dialogue state at each turn based on the dialogue context. The dialogue state is represented as a set of slot-value pairs and can include slots and values from multiple domains. To mitigate data sparsity in few-shot learning, state changes occurring at each turn are used as labels for prediction. \\ 
\end{itemize}

\begin{itemize}
    \item [4)] DST as Text-to-SQL \\
ICL-DST transforms DST into a Text-to-SQL problem by representing dialogue states in SQL format. Each domain is defined as a table, and each slot is defined as a column. All slots and values are included in the \texttt{WHERE} clause. For turns involving multiple domains, each domain is renamed accordingly. This approach aligns well with Azure's OpenAI GPT-4o-mini, enhancing the effectiveness of state prediction. \\
\end{itemize}

\begin{itemize}
    \item [5)] Dialogue Context Representation \\
Instead of including the entire dialogue history, only the most recent \( N \) turns are considered. ICL-DST leverages the fact that the dialogue state is a summary of the dialogue history by representing the dialogue context as \( [y_{t-1}, A_t, U_t] \), where \( y_{t-1} \) denotes the accumulated dialogue state after the previous user turn. \\
\end{itemize}

\begin{itemize}
    \item [6)] In-Context Learning \\
In-Context Learning (ICL) involves keeping the parameters of a pre-trained language model fixed and providing a prompt that includes task descriptions, examples, and test instances. This allows the model to learn patterns within the dialogue context without requiring additional training. By structuring the dialogue state in SQL format, the model can effectively predict the dialogue state based on this representation. \\
\end{itemize}

\begin{itemize}
    \item [7)] Schema Prompting \\
To represent the dialogue schema within the prompt, SQL tables are used for each domain. Each table consists of rows for slot names and example values associated with each slot. For slots with many possible values, only a few example values are listed to maintain prompt efficiency. In experiments, SQL tables for all domains are generated and concatenated to form part of the input. \\ 
\end{itemize}

\begin{itemize}
    \item [8)] In-Context Examples \\
In few-shot scenarios, a retriever system takes the dialogue context \( [y_{t-1}, A_t, U_t] \) as input and retrieves similar examples from a labeled training set. Using the dialogue state \( y_{t-1} \) instead of the full dialogue history allows for shorter inputs, enabling the inclusion of more examples and more effective similarity scoring. In zero-shot scenarios, in-context examples are formatted as example turns. \\
\end{itemize}

\begin{itemize}
    \item [9)] Dialogue Retriever \\
The success of ICL in few-shot environments heavily depends on the quality of in-context examples. ICL-DST extends retrieval to encompass the entire dialogue history by utilizing embedding models like S-BERT to compute the similarity of dialogue states. This allows for the effective extraction of relevant example dialogues that exhibit similar state changes, ensuring accurate state prediction. \\
\end{itemize}

\subsection{Dataset}

We created a custom dataset for appliance conversations using Azure OpenAI: GPT-4-mini, following the structure of the well-known multiWOZ dataset. The dataset is specifically designed to suit interactions between smart appliances while maintaining the schema and format of multiWOZ. \\

\begin{itemize} 
    \item [1)] Dataset Creation Conditions
    \begin{enumerate}
        \item Each dialogue involves at least one and up to three appliances participating in the conversation.
        \item OpenAI's structured output functionality was utilized to ensure the dataset adheres to a consistent JSON format. \\
    \end{enumerate}
\end{itemize}


\begin{itemize}
    \item [2)] Dataset Volume
    \begin{enumerate}
    \item A total of 1,000 dialogues were generated, far exceeding the 80 dialogues that are considered sufficient for many research applications.
    \item This larger volume addresses potential accuracy concerns arising from automated generation, providing robustness through diversity and scale. \\
    \end{enumerate}
\end{itemize}


\begin{itemize}
    \item [3)] Comparison with multiWOZ
    \begin{enumerate}
    \item The multiWOZ dataset was manually curated, ensuring high accuracy for its dialogues. However, its design is tailored for human-to-human or human-to-machine interactions.
    \item In contrast, our dataset is adapted specifically for appliance-to-appliance and appliance-to-human interactions, replicating multiWOZ’s structural principles while introducing scenarios unique to smart home environments.
    \item By focusing on quantity and domain-specific relevance, we offset any limitations from the automated generation process, ensuring the dataset remains effective and practical for AI training. \\
    \end{enumerate}
\end{itemize}

This approach ensures the dataset is not only scalable but also tailored to the unique needs of smart home technology, bridging the gap between manual curation and large-scale automation.



\section{APPENDIX}

\label{app: Database Entity Relationship Diagram}
    \begin{figure}[h]
    \centering
    \includegraphics[width=1.9\columnwidth]{img/architecture/erd.png}
    \label{fig}
    \caption{Database Entity Relationship Diagram}
    \end{figure}

\clearpage

\begin{thebibliography}{9}
\bibitem{opensurvey}“opensurvey,"https://blog.opensurvey.co.kr/trendreport/smart-home-2023/, 2023.
\bibitem{ReactNative}  “React Native,” https://reactnative.dev/, 2023.
\bibitem{Typescript}  “Typescript,” https://www.typescriptlang.org/, 2023.
\bibitem{Kotlin}  “Kotlin,” https://kotlinlang.org/, 2023.
\bibitem{SpringBoot}  “SpringBoot,” https://spring.io/projects/spring-boot, 2023.
\bibitem{Hibernate}  “Hivernate,” https://hibernate.org/, 2023.
\bibitem{FastAPI} “FastAPI,” https://fastapi.tiangolo.com/, 2023.


\end{thebibliography}

\end{document}
